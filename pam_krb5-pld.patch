diff -Nur pam_krb5-1.0-1/Makefile pam_krb5-1.0-1.orig/Makefile
--- pam_krb5-1.0-1/Makefile	Wed Dec 24 01:16:44 1997
+++ pam_krb5-1.0-1.orig/Makefile	Mon Dec 14 15:42:43 1998
@@ -4,9 +4,9 @@
 # make all
 
 # Set these parameters!!
-KRBINCLUDE=-I/usr/local/include
-KRBLIB=-L/usr/local/lib
-KRBSOURCE=/usr/local/src/krb5-1.0.4/krb5-1.0.4/src
+KRBINCLUDE=-I/usr/include
+KRBLIB=-L/usr/lib
+KRBSOURCE=../krb5-1.0.6/src
 SECUREDIR=/lib/security
 #as default, it produces dynamic library
 DYNAMIC=1
@@ -70,7 +70,7 @@
 $(LIBOBJD): $(LIBSRC)
 
 $(LIBSHARED):	$(LIBOBJD)
-	$(LD) -x --shared -o $@ $(LIBOBJD) $(PLUS) $(KRBLIB) -lkadm5clnt -lgssrpc -lgssapi_krb5 -lkdb5   -lkrb5 -lcrypto  -ldyn $(KRBSOURCE)/lib/libdb.a -lcom_err
+	$(LD) -x --shared -o $@ $(LIBOBJD) $(PLUS) $(KRBLIB) -lkadm5clnt -lgssrpc -lgssapi_krb5 -lkdb5   -lkrb5 -lcrypto  -ldyn $(KRBSOURCE)/lib/libdb.a -lcom_err /usr/lib/libc_nonshared.a
 
 
 endif
@@ -79,13 +79,13 @@
 $(LIBOBJS): $(LIBSRC)
 
 $(LIBSTATIC): $(LIBOBJS)
-	$(LD) -r -o $@ $(LIBOBJS) $(PLUS) $(KRBLIB) -lkadm5clnt -lgssrpc -lgssapi_krb5 -lkdb5   -lkrb5 -lcrypto  -ldyn $(KRBSOURCE)/lib/libdb.a -lcom_err
+	$(LD) -r -o $@ $(LIBOBJS) $(PLUS) $(KRBLIB) -lkadm5clnt -lgssrpc -lgssapi_krb5 -lkdb5 -lkrb5 -lcrypto  -ldyn $(KRBSOURCE)/lib/libdb.a -lcom_err
 
 endif
 
 install: all
 ifdef DYNAMIC
-	install -m644 $(LIBSHARED) $(SECUREDIR)/$(TITLE).so
+	install -m755 $(LIBSHARED) $(SECUREDIR)/$(TITLE).so
 endif
 
 remove:
diff -Nur pam_krb5-1.0-1/admin.h pam_krb5-1.0-1.orig/admin.h
--- pam_krb5-1.0-1/admin.h	Thu Jan  1 01:00:00 1970
+++ pam_krb5-1.0-1.orig/admin.h	Mon Dec 14 15:40:56 1998
@@ -0,0 +1,642 @@
+/*
+ * Copyright 1993 OpenVision Technologies, Inc., All Rights Reserved
+ *
+ * $Header$
+ */
+
+#ifndef __KADM5_ADMIN_H__
+#define __KADM5_ADMIN_H__
+
+#if !defined(USE_KADM5_API_VERSION)
+#define USE_KADM5_API_VERSION 2
+#endif
+     
+#include	<sys/types.h>
+#include	<rpc/rpc.h>
+#include	<krb5.h>
+#include	<k5-int.h>
+#include	<com_err.h>
+#include	<kadm5/kadm_err.h>
+#include	<kadm5/adb_err.h>
+#include	<kadm5/chpass_util_strings.h>
+
+#define KADM5_ADMIN_SERVICE	"kadmin/admin"
+#define KADM5_CHANGEPW_SERVICE	"kadmin/changepw"
+#define KADM5_HIST_PRINCIPAL	"kadmin/history"
+
+typedef krb5_principal	kadm5_princ_t;
+typedef	char		*kadm5_policy_t;
+typedef long		kadm5_ret_t;
+
+#define KADM5_PW_FIRST_PROMPT \
+	((char *) error_message(CHPASS_UTIL_NEW_PASSWORD_PROMPT))
+#define KADM5_PW_SECOND_PROMPT \
+	((char *) error_message(CHPASS_UTIL_NEW_PASSWORD_AGAIN_PROMPT))
+
+/*
+ * Succsessfull return code
+ */
+#define KADM5_OK	0
+
+/*
+ * Field masks
+ */
+
+/* kadm5_principal_ent_t */
+#define KADM5_PRINCIPAL		0x000001
+#define KADM5_PRINC_EXPIRE_TIME	0x000002
+#define KADM5_PW_EXPIRATION	0x000004
+#define KADM5_LAST_PWD_CHANGE	0x000008
+#define KADM5_ATTRIBUTES	0x000010
+#define KADM5_MAX_LIFE		0x000020
+#define KADM5_MOD_TIME		0x000040
+#define KADM5_MOD_NAME		0x000080
+#define KADM5_KVNO		0x000100
+#define KADM5_MKVNO		0x000200
+#define KADM5_AUX_ATTRIBUTES	0x000400
+#define KADM5_POLICY		0x000800
+#define KADM5_POLICY_CLR	0x001000
+/* version 2 masks */
+#define KADM5_MAX_RLIFE		0x002000
+#define KADM5_LAST_SUCCESS	0x004000
+#define KADM5_LAST_FAILED	0x008000
+#define KADM5_FAIL_AUTH_COUNT	0x010000
+#define KADM5_KEY_DATA		0x020000
+#define KADM5_TL_DATA		0x040000
+/* all but KEY_DATA and TL_DATA */
+#define KADM5_PRINCIPAL_NORMAL_MASK 0x01ffff
+
+/* kadm5_policy_ent_t */
+#define KADM5_PW_MAX_LIFE	0x004000
+#define KADM5_PW_MIN_LIFE	0x008000
+#define KADM5_PW_MIN_LENGTH	0x010000
+#define KADM5_PW_MIN_CLASSES	0x020000
+#define KADM5_PW_HISTORY_NUM	0x040000
+#define KADM5_REF_COUNT		0x080000
+
+/* kadm5_config_params */
+#define KADM5_CONFIG_REALM		0x000001
+#define KADM5_CONFIG_DBNAME		0x000002
+#define KADM5_CONFIG_MKEY_NAME		0x000004
+#define KADM5_CONFIG_MAX_LIFE		0x000008
+#define KADM5_CONFIG_MAX_RLIFE		0x000010
+#define KADM5_CONFIG_EXPIRATION		0x000020
+#define KADM5_CONFIG_FLAGS		0x000040
+#define KADM5_CONFIG_ADMIN_KEYTAB	0x000080
+#define KADM5_CONFIG_STASH_FILE		0x000100
+#define KADM5_CONFIG_ENCTYPE		0x000200
+#define KADM5_CONFIG_ADBNAME		0x000400
+#define KADM5_CONFIG_ADB_LOCKFILE	0x000800
+#define KADM5_CONFIG_PROFILE		0x001000
+#define KADM5_CONFIG_ACL_FILE		0x002000
+#define KADM5_CONFIG_KADMIND_PORT	0x004000
+#define KADM5_CONFIG_ENCTYPES		0x008000
+#define KADM5_CONFIG_ADMIN_SERVER	0x010000
+#define KADM5_CONFIG_DICT_FILE		0x020000
+#define KADM5_CONFIG_MKEY_FROM_KBD	0x040000
+   
+/*
+ * permission bits
+ */
+#define KADM5_PRIV_GET		0x01
+#define KADM5_PRIV_ADD		0x02
+#define KADM5_PRIV_MODIFY	0x04
+#define KADM5_PRIV_DELETE	0x08
+
+/*
+ * API versioning constants
+ */
+#define KADM5_MASK_BITS		0xffffff00
+
+#define KADM5_STRUCT_VERSION_MASK	0x12345600
+#define KADM5_STRUCT_VERSION_1	(KADM5_STRUCT_VERSION_MASK|0x01)
+#define KADM5_STRUCT_VERSION	KADM5_STRUCT_VERSION_1
+
+#define KADM5_API_VERSION_MASK	0x12345700
+#define KADM5_API_VERSION_1	(KADM5_API_VERSION_MASK|0x01)
+#define KADM5_API_VERSION_2	(KADM5_API_VERSION_MASK|0x02)
+
+typedef struct _kadm5_principal_ent_t_v2 {
+	krb5_principal	principal;
+	krb5_timestamp	princ_expire_time;
+	krb5_timestamp	last_pwd_change;
+	krb5_timestamp	pw_expiration;
+	krb5_deltat	max_life;
+	krb5_principal	mod_name;
+	krb5_timestamp	mod_date;
+	krb5_flags	attributes;
+	krb5_kvno	kvno;
+	krb5_kvno	mkvno;
+	char		*policy;
+	long		aux_attributes;
+
+	/* version 2 fields */
+	krb5_deltat max_renewable_life;
+        krb5_timestamp last_success;
+        krb5_timestamp last_failed;
+        krb5_kvno fail_auth_count;
+	krb5_int16 n_key_data;
+	krb5_int16 n_tl_data;
+        krb5_tl_data *tl_data;
+	krb5_key_data *key_data;
+} kadm5_principal_ent_rec_v2, *kadm5_principal_ent_t_v2;
+
+typedef struct _kadm5_principal_ent_t_v1 {
+	krb5_principal	principal;
+	krb5_timestamp	princ_expire_time;
+	krb5_timestamp	last_pwd_change;
+	krb5_timestamp	pw_expiration;
+	krb5_deltat	max_life;
+	krb5_principal	mod_name;
+	krb5_timestamp	mod_date;
+	krb5_flags	attributes;
+	krb5_kvno	kvno;
+	krb5_kvno	mkvno;
+	char		*policy;
+	long		aux_attributes;
+} kadm5_principal_ent_rec_v1, *kadm5_principal_ent_t_v1;
+
+#if USE_KADM5_API_VERSION == 1
+typedef struct _kadm5_principal_ent_t_v1
+     kadm5_principal_ent_rec, *kadm5_principal_ent_t;
+#else
+typedef struct _kadm5_principal_ent_t_v2
+     kadm5_principal_ent_rec, *kadm5_principal_ent_t;
+#endif
+
+typedef struct _kadm5_policy_ent_t {
+	char		*policy;
+	long		pw_min_life;
+	long		pw_max_life;
+	long		pw_min_length;
+	long		pw_min_classes;
+	long		pw_history_num;
+	long		policy_refcnt;
+} kadm5_policy_ent_rec, *kadm5_policy_ent_t;
+
+typedef struct __krb5_key_salt_tuple {
+     krb5_enctype	ks_enctype;
+     krb5_int32		ks_salttype;
+} krb5_key_salt_tuple;
+
+/*
+ * Data structure returned by kadm5_get_config_params()
+ */
+typedef struct _kadm5_config_params {
+     long		mask;
+     char *		realm;
+     char *		profile;
+     int		kadmind_port;
+
+     char *		admin_server;
+
+     char *		dbname;
+     char *		admin_dbname;
+     char *		admin_lockfile;
+     char *		admin_keytab;
+     char *		acl_file;
+     char *		dict_file;
+
+     int		mkey_from_kbd;
+     char *		stash_file;
+     char *		mkey_name;
+     krb5_enctype	enctype;
+     krb5_deltat	max_life;
+     krb5_deltat	max_rlife;
+     krb5_timestamp	expiration;
+     krb5_flags		flags;
+     krb5_key_salt_tuple *keysalts;
+     krb5_int32		num_keysalts;
+} kadm5_config_params;
+
+/***********************************************************************
+ * This is the old krb5_realm_read_params, which I mutated into
+ * kadm5_get_config_params but which old code (kdb5_* and krb5kdc)
+ * still uses.
+ ***********************************************************************/
+
+/*
+ * Data structure returned by krb5_read_realm_params()
+ */
+typedef struct __krb5_realm_params {
+    char *		realm_profile;
+    char *		realm_dbname;
+    char *		realm_mkey_name;
+    char *		realm_stash_file;
+    char *		realm_kdc_ports;
+    char *		realm_acl_file;
+    krb5_int32		realm_kadmind_port;
+    krb5_enctype	realm_enctype;
+    krb5_deltat		realm_max_life;
+    krb5_deltat		realm_max_rlife;
+    krb5_timestamp	realm_expiration;
+    krb5_flags		realm_flags;
+    krb5_key_salt_tuple	*realm_keysalts;
+    unsigned int	realm_kadmind_port_valid:1;
+    unsigned int	realm_enctype_valid:1;
+    unsigned int	realm_max_life_valid:1;
+    unsigned int	realm_max_rlife_valid:1;
+    unsigned int	realm_expiration_valid:1;
+    unsigned int	realm_flags_valid:1;
+    unsigned int	realm_filler:7;
+    krb5_int32		realm_num_keysalts;
+} krb5_realm_params;
+
+/*
+ * functions
+ */
+
+#if USE_KADM5_API_VERSION > 1
+krb5_error_code kadm5_get_config_params(krb5_context context,
+					char *kdcprofile, char *kdcenv,
+					kadm5_config_params *params_in,
+					kadm5_config_params *params_out);
+krb5_error_code kadm5_free_realm_params(krb5_context kcontext,
+					kadm5_config_params *params);
+#endif
+
+kadm5_ret_t    kadm5_init(char *client_name, char *pass,
+			  char *service_name,
+#if USE_KADM5_API_VERSION == 1
+			  char *realm,
+#else
+			  kadm5_config_params *params,
+#endif
+			  krb5_ui_4 struct_version,
+			  krb5_ui_4 api_version,
+			  void **server_handle);
+kadm5_ret_t    kadm5_init_with_password(char *client_name,
+					char *pass, 
+					char *service_name,
+#if USE_KADM5_API_VERSION == 1
+					char *realm,
+#else
+					kadm5_config_params *params,
+#endif
+					krb5_ui_4 struct_version,
+					krb5_ui_4 api_version,
+					void **server_handle);
+kadm5_ret_t    kadm5_init_with_skey(char *client_name,
+				    char *keytab,
+				    char *service_name,
+#if USE_KADM5_API_VERSION == 1
+				    char *realm,
+#else
+				    kadm5_config_params *params,
+#endif
+				    krb5_ui_4 struct_version,
+				    krb5_ui_4 api_version,
+				    void **server_handle);
+#if USE_KADM5_API_VERSION > 1
+kadm5_ret_t    kadm5_init_with_creds(char *client_name,
+				     krb5_ccache cc,
+				     char *service_name,
+				     kadm5_config_params *params,
+				     krb5_ui_4 struct_version,
+				     krb5_ui_4 api_version,
+				     void **server_handle);
+#endif
+kadm5_ret_t    kadm5_flush(void *server_handle);
+kadm5_ret_t    kadm5_destroy(void *server_handle);
+kadm5_ret_t    kadm5_create_principal(void *server_handle,
+				      kadm5_principal_ent_t ent,
+				      long mask, char *pass);
+kadm5_ret_t    kadm5_delete_principal(void *server_handle,
+				      krb5_principal principal);
+kadm5_ret_t    kadm5_modify_principal(void *server_handle,
+				      kadm5_principal_ent_t ent,
+				      long mask);
+kadm5_ret_t    kadm5_rename_principal(void *server_handle,
+				      krb5_principal,krb5_principal);
+#if USE_KADM5_API_VERSION == 1
+kadm5_ret_t    kadm5_get_principal(void *server_handle,
+				   krb5_principal principal,
+				   kadm5_principal_ent_t *ent);
+#else
+kadm5_ret_t    kadm5_get_principal(void *server_handle,
+				   krb5_principal principal,
+				   kadm5_principal_ent_t ent,
+				   long mask);
+#endif
+kadm5_ret_t    kadm5_chpass_principal(void *server_handle,
+				      krb5_principal principal,
+				      char *pass);
+#if USE_KADM5_API_VERSION == 1
+kadm5_ret_t    kadm5_randkey_principal(void *server_handle,
+				       krb5_principal principal,
+				       krb5_keyblock **keyblock);
+#else
+kadm5_ret_t    kadm5_randkey_principal(void *server_handle,
+				       krb5_principal principal,
+				       krb5_keyblock **keyblocks,
+				       int *n_keys);
+#endif
+kadm5_ret_t    kadm5_create_policy(void *server_handle,
+				   kadm5_policy_ent_t ent,
+				   long mask);
+/*
+ * kadm5_create_policy_internal is not part of the supported,
+ * exposed API.  It is available only in the server library, and you
+ * shouldn't use it unless you know why it's there and how it's
+ * different from kadm5_create_policy.
+ */
+kadm5_ret_t    kadm5_create_policy_internal(void *server_handle,
+					    kadm5_policy_ent_t
+					    entry, long mask);
+kadm5_ret_t    kadm5_delete_policy(void *server_handle,
+				   kadm5_policy_t policy);
+kadm5_ret_t    kadm5_modify_policy(void *server_handle,
+				   kadm5_policy_ent_t ent,
+				   long mask);
+/*
+ * kadm5_modify_policy_internal is not part of the supported,
+ * exposed API.  It is available only in the server library, and you
+ * shouldn't use it unless you know why it's there and how it's
+ * different from kadm5_modify_policy.
+ */
+kadm5_ret_t    kadm5_modify_policy_internal(void *server_handle,
+					    kadm5_policy_ent_t
+					    entry, long mask);
+#if USE_KADM5_API_VERSION == 1
+kadm5_ret_t    kadm5_get_policy(void *server_handle,
+				kadm5_policy_t policy,
+				kadm5_policy_ent_t *ent);
+#else
+kadm5_ret_t    kadm5_get_policy(void *server_handle,
+				kadm5_policy_t policy,
+				kadm5_policy_ent_t ent);
+#endif
+kadm5_ret_t    kadm5_get_privs(void *server_handle,
+			       long *privs);
+
+kadm5_ret_t    kadm5_chpass_principal_util(void *server_handle,
+					   krb5_principal princ,
+					   char *new_pw, 
+					   char **ret_pw,
+					   char *msg_ret);
+
+kadm5_ret_t    kadm5_free_principal_ent(void *server_handle,
+					kadm5_principal_ent_t
+					ent);
+kadm5_ret_t    kadm5_free_policy_ent(void *server_handle,
+				     kadm5_policy_ent_t ent);
+
+kadm5_ret_t    kadm5_get_principals(void *server_handle,
+				    char *exp, char ***princs,
+				    int *count);
+
+kadm5_ret_t    kadm5_get_policies(void *server_handle,
+				  char *exp, char ***pols,
+				  int *count);
+
+#if USE_KADM5_API_VERSION > 1
+kadm5_ret_t    kadm5_free_key_data(void *server_handle,
+				   krb5_int16 *n_key_data,
+				   krb5_key_data *key_data);
+#endif
+
+#if USE_KADM5_API_VERSION == 1
+/*
+ * OVSEC_KADM_API_VERSION_1 should be, if possible, compile-time
+ * compatible with KADM5_API_VERSION_2.  Basically, this means we have
+ * to continue to provide all the old ovsec_kadm function and symbol
+ * names.
+ */
+
+#define OVSEC_KADM_ACLFILE		"/krb5/ovsec_adm.acl"
+#define	OVSEC_KADM_WORDFILE		"/krb5/ovsec_adm.dict"
+
+#define OVSEC_KADM_ADMIN_SERVICE	"ovsec_adm/admin"
+#define OVSEC_KADM_CHANGEPW_SERVICE	"ovsec_adm/changepw"
+#define OVSEC_KADM_HIST_PRINCIPAL	"ovsec_adm/history"
+
+typedef krb5_principal	ovsec_kadm_princ_t;
+typedef krb5_keyblock	ovsec_kadm_keyblock;
+typedef	char		*ovsec_kadm_policy_t;
+typedef long		ovsec_kadm_ret_t;
+
+enum	ovsec_kadm_salttype { OVSEC_KADM_SALT_V4, OVSEC_KADM_SALT_NORMAL };
+enum	ovsec_kadm_saltmod  { OVSEC_KADM_MOD_KEEP, OVSEC_KADM_MOD_V4, OVSEC_KADM_MOD_NORMAL };
+
+#define OVSEC_KADM_PW_FIRST_PROMPT \
+	((char *) error_message(CHPASS_UTIL_NEW_PASSWORD_PROMPT))
+#define OVSEC_KADM_PW_SECOND_PROMPT \
+	((char *) error_message(CHPASS_UTIL_NEW_PASSWORD_AGAIN_PROMPT))
+
+/*
+ * Succsessfull return code
+ */
+#define OVSEC_KADM_OK	0
+ 
+/*
+ * Create/Modify masks
+ */
+/* principal */
+#define OVSEC_KADM_PRINCIPAL		0x000001
+#define OVSEC_KADM_PRINC_EXPIRE_TIME	0x000002
+#define OVSEC_KADM_PW_EXPIRATION	0x000004
+#define OVSEC_KADM_LAST_PWD_CHANGE	0x000008
+#define OVSEC_KADM_ATTRIBUTES		0x000010
+#define OVSEC_KADM_MAX_LIFE		0x000020
+#define OVSEC_KADM_MOD_TIME		0x000040
+#define OVSEC_KADM_MOD_NAME		0x000080
+#define OVSEC_KADM_KVNO			0x000100
+#define OVSEC_KADM_MKVNO		0x000200
+#define OVSEC_KADM_AUX_ATTRIBUTES	0x000400
+#define OVSEC_KADM_POLICY		0x000800
+#define OVSEC_KADM_POLICY_CLR		0x001000
+/* policy */
+#define OVSEC_KADM_PW_MAX_LIFE		0x004000
+#define OVSEC_KADM_PW_MIN_LIFE		0x008000
+#define OVSEC_KADM_PW_MIN_LENGTH	0x010000
+#define OVSEC_KADM_PW_MIN_CLASSES	0x020000
+#define OVSEC_KADM_PW_HISTORY_NUM	0x040000
+#define OVSEC_KADM_REF_COUNT		0x080000
+
+/*
+ * permission bits
+ */
+#define OVSEC_KADM_PRIV_GET	0x01
+#define OVSEC_KADM_PRIV_ADD	0x02
+#define OVSEC_KADM_PRIV_MODIFY	0x04
+#define OVSEC_KADM_PRIV_DELETE	0x08
+
+/*
+ * API versioning constants
+ */
+#define OVSEC_KADM_MASK_BITS		0xffffff00
+
+#define OVSEC_KADM_STRUCT_VERSION_MASK	0x12345600
+#define OVSEC_KADM_STRUCT_VERSION_1	(OVSEC_KADM_STRUCT_VERSION_MASK|0x01)
+#define OVSEC_KADM_STRUCT_VERSION	OVSEC_KADM_STRUCT_VERSION_1
+
+#define OVSEC_KADM_API_VERSION_MASK	0x12345700
+#define OVSEC_KADM_API_VERSION_1	(OVSEC_KADM_API_VERSION_MASK|0x01)
+
+
+typedef struct _ovsec_kadm_principal_ent_t {
+	krb5_principal	principal;
+	krb5_timestamp	princ_expire_time;
+	krb5_timestamp	last_pwd_change;
+	krb5_timestamp	pw_expiration;
+	krb5_deltat	max_life;
+	krb5_principal	mod_name;
+	krb5_timestamp	mod_date;
+	krb5_flags	attributes;
+	krb5_kvno	kvno;
+	krb5_kvno	mkvno;
+	char		*policy;
+	long		aux_attributes;
+} ovsec_kadm_principal_ent_rec, *ovsec_kadm_principal_ent_t;
+
+typedef struct _ovsec_kadm_policy_ent_t {
+	char		*policy;
+	long		pw_min_life;
+	long		pw_max_life;
+	long		pw_min_length;
+	long		pw_min_classes;
+	long		pw_history_num;
+	long		policy_refcnt;
+} ovsec_kadm_policy_ent_rec, *ovsec_kadm_policy_ent_t;
+
+/*
+ * functions
+ */
+ovsec_kadm_ret_t    ovsec_kadm_init(char *client_name, char *pass,
+				    char *service_name, char *realm,
+				    krb5_ui_4 struct_version,
+				    krb5_ui_4 api_version,
+				    void **server_handle);
+ovsec_kadm_ret_t    ovsec_kadm_init_with_password(char *client_name,
+						  char *pass, 
+						  char *service_name,
+						  char *realm, 
+						  krb5_ui_4 struct_version,
+						  krb5_ui_4 api_version,
+						  void **server_handle);
+ovsec_kadm_ret_t    ovsec_kadm_init_with_skey(char *client_name,
+					      char *keytab,
+					      char *service_name,
+					      char *realm,
+					      krb5_ui_4 struct_version,
+					      krb5_ui_4 api_version,
+					      void **server_handle);
+ovsec_kadm_ret_t    ovsec_kadm_flush(void *server_handle);
+ovsec_kadm_ret_t    ovsec_kadm_destroy(void *server_handle);
+ovsec_kadm_ret_t    ovsec_kadm_create_principal(void *server_handle,
+						ovsec_kadm_principal_ent_t ent,
+						long mask, char *pass);
+ovsec_kadm_ret_t    ovsec_kadm_delete_principal(void *server_handle,
+						krb5_principal principal);
+ovsec_kadm_ret_t    ovsec_kadm_modify_principal(void *server_handle,
+						ovsec_kadm_principal_ent_t ent,
+						long mask);
+ovsec_kadm_ret_t    ovsec_kadm_rename_principal(void *server_handle,
+						krb5_principal,krb5_principal);
+ovsec_kadm_ret_t    ovsec_kadm_get_principal(void *server_handle,
+					     krb5_principal principal,
+					     ovsec_kadm_principal_ent_t *ent);
+ovsec_kadm_ret_t    ovsec_kadm_chpass_principal(void *server_handle,
+						krb5_principal principal,
+						char *pass);
+ovsec_kadm_ret_t    ovsec_kadm_randkey_principal(void *server_handle,
+						 krb5_principal principal,
+						 krb5_keyblock **keyblock);
+ovsec_kadm_ret_t    ovsec_kadm_create_policy(void *server_handle,
+					     ovsec_kadm_policy_ent_t ent,
+					     long mask);
+/*
+ * ovsec_kadm_create_policy_internal is not part of the supported,
+ * exposed API.  It is available only in the server library, and you
+ * shouldn't use it unless you know why it's there and how it's
+ * different from ovsec_kadm_create_policy.
+ */
+ovsec_kadm_ret_t    ovsec_kadm_create_policy_internal(void *server_handle,
+						      ovsec_kadm_policy_ent_t
+						      entry, long mask);
+ovsec_kadm_ret_t    ovsec_kadm_delete_policy(void *server_handle,
+					     ovsec_kadm_policy_t policy);
+ovsec_kadm_ret_t    ovsec_kadm_modify_policy(void *server_handle,
+					     ovsec_kadm_policy_ent_t ent,
+					     long mask);
+/*
+ * ovsec_kadm_modify_policy_internal is not part of the supported,
+ * exposed API.  It is available only in the server library, and you
+ * shouldn't use it unless you know why it's there and how it's
+ * different from ovsec_kadm_modify_policy.
+ */
+ovsec_kadm_ret_t    ovsec_kadm_modify_policy_internal(void *server_handle,
+						      ovsec_kadm_policy_ent_t
+						      entry, long mask);
+ovsec_kadm_ret_t    ovsec_kadm_get_policy(void *server_handle,
+					  ovsec_kadm_policy_t policy,
+					  ovsec_kadm_policy_ent_t *ent);
+ovsec_kadm_ret_t    ovsec_kadm_get_privs(void *server_handle,
+					 long *privs);
+
+ovsec_kadm_ret_t    ovsec_kadm_chpass_principal_util(void *server_handle,
+						     krb5_principal princ,
+						     char *new_pw, 
+						     char **ret_pw,
+						     char *msg_ret);
+
+ovsec_kadm_ret_t    ovsec_kadm_free_principal_ent(void *server_handle,
+						  ovsec_kadm_principal_ent_t
+						  ent);
+ovsec_kadm_ret_t    ovsec_kadm_free_policy_ent(void *server_handle,
+					       ovsec_kadm_policy_ent_t ent);
+
+ovsec_kadm_ret_t    ovsec_kadm_get_principals(void *server_handle,
+					      char *exp, char ***princs,
+					      int *count);
+
+ovsec_kadm_ret_t    ovsec_kadm_get_policies(void *server_handle,
+					    char *exp, char ***pols,
+					    int *count);
+
+#define OVSEC_KADM_FAILURE KADM5_FAILURE
+#define OVSEC_KADM_AUTH_GET KADM5_AUTH_GET
+#define OVSEC_KADM_AUTH_ADD KADM5_AUTH_ADD
+#define OVSEC_KADM_AUTH_MODIFY KADM5_AUTH_MODIFY
+#define OVSEC_KADM_AUTH_DELETE KADM5_AUTH_DELETE
+#define OVSEC_KADM_AUTH_INSUFFICIENT KADM5_AUTH_INSUFFICIENT
+#define OVSEC_KADM_BAD_DB KADM5_BAD_DB
+#define OVSEC_KADM_DUP KADM5_DUP
+#define OVSEC_KADM_RPC_ERROR KADM5_RPC_ERROR
+#define OVSEC_KADM_NO_SRV KADM5_NO_SRV
+#define OVSEC_KADM_BAD_HIST_KEY KADM5_BAD_HIST_KEY
+#define OVSEC_KADM_NOT_INIT KADM5_NOT_INIT
+#define OVSEC_KADM_UNK_PRINC KADM5_UNK_PRINC
+#define OVSEC_KADM_UNK_POLICY KADM5_UNK_POLICY
+#define OVSEC_KADM_BAD_MASK KADM5_BAD_MASK
+#define OVSEC_KADM_BAD_CLASS KADM5_BAD_CLASS
+#define OVSEC_KADM_BAD_LENGTH KADM5_BAD_LENGTH
+#define OVSEC_KADM_BAD_POLICY KADM5_BAD_POLICY
+#define OVSEC_KADM_BAD_PRINCIPAL KADM5_BAD_PRINCIPAL
+#define OVSEC_KADM_BAD_AUX_ATTR KADM5_BAD_AUX_ATTR
+#define OVSEC_KADM_BAD_HISTORY KADM5_BAD_HISTORY
+#define OVSEC_KADM_BAD_MIN_PASS_LIFE KADM5_BAD_MIN_PASS_LIFE
+#define OVSEC_KADM_PASS_Q_TOOSHORT KADM5_PASS_Q_TOOSHORT
+#define OVSEC_KADM_PASS_Q_CLASS KADM5_PASS_Q_CLASS
+#define OVSEC_KADM_PASS_Q_DICT KADM5_PASS_Q_DICT
+#define OVSEC_KADM_PASS_REUSE KADM5_PASS_REUSE
+#define OVSEC_KADM_PASS_TOOSOON KADM5_PASS_TOOSOON
+#define OVSEC_KADM_POLICY_REF KADM5_POLICY_REF
+#define OVSEC_KADM_INIT KADM5_INIT
+#define OVSEC_KADM_BAD_PASSWORD KADM5_BAD_PASSWORD
+#define OVSEC_KADM_PROTECT_PRINCIPAL KADM5_PROTECT_PRINCIPAL
+#define OVSEC_KADM_BAD_SERVER_HANDLE KADM5_BAD_SERVER_HANDLE
+#define OVSEC_KADM_BAD_STRUCT_VERSION KADM5_BAD_STRUCT_VERSION
+#define OVSEC_KADM_OLD_STRUCT_VERSION KADM5_OLD_STRUCT_VERSION
+#define OVSEC_KADM_NEW_STRUCT_VERSION KADM5_NEW_STRUCT_VERSION
+#define OVSEC_KADM_BAD_API_VERSION KADM5_BAD_API_VERSION
+#define OVSEC_KADM_OLD_LIB_API_VERSION KADM5_OLD_LIB_API_VERSION
+#define OVSEC_KADM_OLD_SERVER_API_VERSION KADM5_OLD_SERVER_API_VERSION
+#define OVSEC_KADM_NEW_LIB_API_VERSION KADM5_NEW_LIB_API_VERSION
+#define OVSEC_KADM_NEW_SERVER_API_VERSION KADM5_NEW_SERVER_API_VERSION
+#define OVSEC_KADM_SECURE_PRINC_MISSING KADM5_SECURE_PRINC_MISSING
+#define OVSEC_KADM_NO_RENAME_SALT KADM5_NO_RENAME_SALT
+
+#endif /* USE_KADM5_API_VERSION == 1 */
+
+#endif /* __KADM5_ADMIN_H__ */
diff -Nur pam_krb5-1.0-1/k5-int.h pam_krb5-1.0-1.orig/k5-int.h
--- pam_krb5-1.0-1/k5-int.h	Thu Jan  1 01:00:00 1970
+++ pam_krb5-1.0-1.orig/k5-int.h	Mon Dec 14 15:40:56 1998
@@ -0,0 +1,1366 @@
+/*
+ * Copyright (C) 1989-1995 by the Massachusetts Institute of Technology,
+ * Cambridge, MA, USA.  All Rights Reserved.
+ * 
+ * This software is being provided to you, the LICENSEE, by the 
+ * Massachusetts Institute of Technology (M.I.T.) under the following 
+ * license.  By obtaining, using and/or copying this software, you agree 
+ * that you have read, understood, and will comply with these terms and 
+ * conditions:  
+ * 
+ * Export of this software from the United States of America may
+ * require a specific license from the United States Government.
+ * It is the responsibility of any person or organization contemplating
+ * export to obtain such a license before exporting.
+ * 
+ * WITHIN THAT CONSTRAINT, permission to use, copy, modify and distribute 
+ * this software and its documentation for any purpose and without fee or 
+ * royalty is hereby granted, provided that you agree to comply with the 
+ * following copyright notice and statements, including the disclaimer, and 
+ * that the same appear on ALL copies of the software and documentation, 
+ * including modifications that you make for internal use or for 
+ * distribution:
+ * 
+ * THIS SOFTWARE IS PROVIDED "AS IS", AND M.I.T. MAKES NO REPRESENTATIONS 
+ * OR WARRANTIES, EXPRESS OR IMPLIED.  By way of example, but not 
+ * limitation, M.I.T. MAKES NO REPRESENTATIONS OR WARRANTIES OF 
+ * MERCHANTABILITY OR FITNESS FOR ANY PARTICULAR PURPOSE OR THAT THE USE OF 
+ * THE LICENSED SOFTWARE OR DOCUMENTATION WILL NOT INFRINGE ANY THIRD PARTY 
+ * PATENTS, COPYRIGHTS, TRADEMARKS OR OTHER RIGHTS.   
+ * 
+ * The name of the Massachusetts Institute of Technology or M.I.T. may NOT 
+ * be used in advertising or publicity pertaining to distribution of the 
+ * software.  Title to copyright in this software and any associated 
+ * documentation shall at all times remain with M.I.T., and USER agrees to 
+ * preserve same.  
+ */
+/*
+ * This prototype for k5-int.h (Krb5 internals include file)
+ * includes the user-visible definitions from krb5.h and then
+ * includes other definitions that are not user-visible but are
+ * required for compiling Kerberos internal routines.
+ *
+ * John Gilmore, Cygnus Support, Sat Jan 21 22:45:52 PST 1995
+ */
+
+#ifndef _KRB5_INT_H
+#define _KRB5_INT_H
+
+#include "osconf.h"
+
+/*
+ * Begin "k5-config.h"
+ */
+#ifndef KRB5_CONFIG__
+#define KRB5_CONFIG__
+
+#if (defined(_MSDOS) || defined(_WIN32))
+/* 
+ * Machine-type definitions: PC Clone 386 running Microloss Windows
+ */
+
+#if defined(_MSDOS)
+	/* Windows 16 specific */
+#define BITS16
+#define SIZEOF_INT      2
+#define SIZEOF_SHORT    2
+#define SIZEOF_LONG     4
+
+#ifndef KRB5_CALLCONV
+#define KRB5_CALLCONV __far __export __pascal
+#define KRB5_CALLCONV_C __far __export __cdecl
+#define KRB5_DLLIMP
+#define INTERFACE   KRB5_CALLCONV
+#define INTERFACE_C KRB5_CALLCONV_C
+#endif /* !KRB5_CALLCONV */
+
+/*
+ * The following defines are needed to make <windows.h> work
+ * in stdc mode (/Za flag). Winsock.h needs <windows.h>.
+ */
+#define FAR     _far
+#define NEAR    _near
+#define _far    __far
+#define _near   __near
+#define _pascal __pascal
+#define _cdecl  __cdecl
+#define _huge   __huge
+
+#ifdef NEED_WINDOWS
+#include <windows.h>
+#endif
+	
+#else 
+	/* Windows 32 specific */
+#define SIZEOF_INT      4
+#define SIZEOF_SHORT    2
+#define SIZEOF_LONG     4
+
+#ifndef KRB5_CALLCONV
+#ifdef KRB5_DLL_FILE
+#define KRB5_DECLSPEC dllexport
+#else
+#define KRB5_DECLSPEC dllimport
+#endif
+#define KRB5_DLLIMP __declspec(KRB5_DECLSPEC)
+#define KRB5_CALLCONV __stdcall
+#define KRB5_CALLCONV_C __cdecl
+#define INTERFACE   KRB5_DLLIMP KRB5_CALLCONV
+#define INTERFACE_C KRB5_DLLIMP KRB5_CALLCONV_C
+#endif /* !KRB5_CALLCONV */
+
+#include <windows.h>
+#endif
+	
+/* Kerberos Windows initialization file */
+#define KERBEROS_INI    "kerberos.ini"
+#define INI_FILES       "Files"
+#define INI_KRB_CCACHE  "krb5cc"       /* Location of the ccache */
+#define INI_KRB5_CONF   "krb5.ini"		/* Location of krb5.conf file */
+
+#define MAXHOSTNAMELEN  512
+#define MAXPATHLEN      256            /* Also for Windows temp files */
+
+#define KRB5_USE_INET
+#define MSDOS_FILESYSTEM
+#define USE_STRING_H 
+#define HAVE_SRAND
+#define HAVE_ERRNO
+#define HAS_STRDUP
+#define NO_USERID
+#define NOFCHMOD
+#define NOCHMOD
+#define NO_PASSWORD
+#define WM_KERBEROS5_CHANGED "Kerberos5 Changed"
+
+#define HAS_ANSI_VOLATILE
+#define HAS_VOID_TYPE
+#define	KRB5_PROVIDE_PROTOTYPES
+#define HAVE_STDARG_H
+#define HAVE_SYS_TYPES_H
+#define HAS_STDLIB_H
+
+/* This controls which encryption routines libcrypto will provide */
+#define PROVIDE_DES_CBC_MD5
+#define PROVIDE_DES_CBC_CRC
+#define PROVIDE_DES_CBC_RAW
+#define PROVIDE_DES_CBC_CKSUM
+/* #define PROVIDE_DES3_CBC_SHA */
+/* #define PROVIDE_DES3_CBC_RAW */
+#define PROVIDE_CRC32
+#define PROVIDE_RSA_MD4
+#define PROVIDE_RSA_MD5
+/* #define PROVIDE_NIST_SHA */
+
+#ifndef _SIZE_T_DEFINED
+typedef unsigned int size_t;
+#define _SIZE_T_DEFINED
+#endif 
+
+#ifndef KRB5_SYSTYPES__
+#define KRB5_SYSTYPES__
+#include <sys/types.h>
+typedef unsigned long u_long;      /* Not part of sys/types.h on the pc */
+typedef unsigned int	u_int;
+typedef unsigned short	u_short;
+typedef unsigned char	u_char;
+#endif /* KRB5_SYSTYPES__ */
+
+
+#ifdef NEED_LOWLEVEL_IO
+/* Ugly. Microsoft, in stdc mode, doesn't support the low-level i/o
+ * routines directly. Rather, they only export the _<function> version.
+ * The following defines works around this problem. 
+ */
+#include <sys\types.h>
+#include <sys\stat.h>
+#include <fcntl.h>
+#include <io.h>
+#include <process.h>
+#define THREEPARAMOPEN(x,y,z) open(x,y,z)
+#define O_RDONLY        _O_RDONLY
+#define O_WRONLY        _O_WRONLY
+#define O_RDWR          _O_RDWR
+#define O_APPEND        _O_APPEND
+#define O_CREAT         _O_CREAT
+#define O_TRUNC         _O_TRUNC
+#define O_EXCL          _O_EXCL
+#define O_TEXT          _O_TEXT
+#define O_BINARY        _O_BINARY
+#define O_NOINHERIT     _O_NOINHERIT
+#define stat            _stat
+#define unlink          _unlink
+#define lseek           _lseek
+#define write           _write
+#define open            _open
+#define close           _close
+#define read            _read
+#define fstat           _fstat
+#define mktemp          _mktemp
+#define dup             _dup
+
+#define getpid          _getpid
+#endif
+
+#ifdef NEED_SYSERROR
+/* Only needed by util/et/error_message.c but let's keep the source clean */
+#define sys_nerr        _sys_nerr
+#define sys_errlist     _sys_errlist
+#endif
+
+#define DEFAULT_PWD_STRING1 "Enter password:"
+#define DEFAULT_PWD_STRING2 "Re-enter password for verification:"
+
+/* Functions with slightly different names on the PC
+*/                   
+#define strcasecmp   _stricmp
+#define strncasecmp  _strnicmp
+#define strdup       _strdup
+#define off_t        _off_t
+int sscanf(const char *str, char const *fmt0, ...);
+
+#else 		/* Rest of include file is for non-Microloss-Windows */
+
+#ifndef _MACINTOSH
+#if defined(__MWERKS__) || defined(applec) || defined(THINK_C)
+#define _MACINTOSH
+#define SIZEOF_INT 4
+#define SIZEOF_SHORT 2
+#define HAVE_SRAND
+#define NO_PASSWORD
+#define HAS_LABS
+#define ENOMEM -1
+#define ANSI_STDIO
+#ifndef _SIZET
+typedef unsigned int size_t;
+#define _SIZET
+#endif
+#include <unix.h>
+#include <ctype.h>
+#endif
+#endif
+
+#if defined(_MACINTOSH)
+
+#ifdef NEED_LOWLEVEL_IO
+#include <fcntl.h>
+#endif
+
+/*
+ * Which encryption routines libcrypto will provide is controlled by
+ * mac/libraries/KerberosHeaders.h.
+ */
+
+/* there is no <stat.h> for mpw */
+typedef unsigned long	mode_t;
+typedef unsigned long	ino_t;
+typedef unsigned long	dev_t;
+typedef short			nlink_t;
+typedef unsigned long	uid_t;
+typedef unsigned long	gid_t;
+typedef long			off_t;
+
+#ifndef __MWERKS__
+struct stat
+{
+	mode_t		st_mode;		/* File mode; see #define's below */
+	ino_t		st_ino;			/* File serial number */
+	dev_t		st_dev;			/* ID of device containing this file */
+	nlink_t		st_nlink;		/* Number of links */
+	uid_t		st_uid;			/* User ID of the file's owner */
+	gid_t		st_gid;			/* Group ID of the file's group */
+	dev_t		st_rdev;		/* Device type */
+	off_t		st_size;		/* File size in bytes */
+	unsigned long		st_atime;		/* Time of last access */
+	unsigned long		st_mtime;		/* Time of last data modification */
+	unsigned long		st_ctime;		/* Time of last file status change */
+	long		st_blksize;		/* Optimal blocksize */
+	long		st_blocks;		/* blocks allocated for file */
+};
+
+int stat(const char *path, struct stat *buf);
+#endif
+
+int fstat(int fildes, struct stat *buf);
+
+#define EFBIG 1000
+
+#define NOFCHMOD 1
+#define NOCHMOD 1
+#define _MACSOCKAPI_
+
+#define THREEPARAMOPEN(x,y,z) open(x,y)
+#else /* _MACINTOSH */
+#define THREEPARAMOPEN(x,y,z) open(x,y,z)
+#endif /* _MACINTOSH */
+
+#ifndef KRB5_AUTOCONF__
+#define KRB5_AUTOCONF__
+#include "autoconf.h"
+#endif
+
+#ifndef KRB5_SYSTYPES__
+#define KRB5_SYSTYPES__
+
+#ifdef HAVE_SYS_TYPES_H		/* From autoconf.h */
+#include <sys/types.h>
+#else /* HAVE_SYS_TYPES_H */
+typedef unsigned long 	u_long;
+typedef unsigned int	u_int;
+typedef unsigned short	u_short;
+typedef unsigned char	u_char;
+#endif /* HAVE_SYS_TYPES_H */
+#endif /* KRB5_SYSTYPES__ */
+
+#ifdef SYSV
+/* Change srandom and random to use rand and srand */
+/* Taken from the Sandia changes.  XXX  We should really just include */
+/* srandom and random into Kerberos release, since rand() is a really */
+/* bad random number generator.... [tytso:19920616.2231EDT] */
+#define random() rand()
+#define srandom(a) srand(a)
+#ifndef unicos61
+#define utimes(a,b) utime(a,b)
+#endif  /* unicos61 */
+#endif /* SYSV */
+
+#define DEFAULT_PWD_STRING1 "Enter password:"
+#define DEFAULT_PWD_STRING2 "Re-enter password for verification:"
+
+#define	KRB5_KDB_MAX_LIFE	(60*60*24) /* one day */
+#define	KRB5_KDB_MAX_RLIFE	(60*60*24*7) /* one week */
+#define	KRB5_KDB_EXPIRATION	2145830400 /* Thu Jan  1 00:00:00 2038 UTC */
+
+/* 
+ * Windows requires a different api interface to each function. Here
+ * just define it as NULL.
+ */
+#ifndef KRB5_CALLCONV
+#define KRB5_CALLCONV
+#define KRB5_CALLCONV_C
+#define KRB5_DLLIMP
+#define INTERFACE
+#define INTERFACE_C
+#define FAR
+#define NEAR
+#endif
+#ifndef O_BINARY
+#define O_BINARY 0
+#endif
+
+#ifndef HAS_LABS
+#define labs(x) abs(x)
+#endif
+
+#endif /* _MSDOS */
+#endif /* KRB5_CONFIG__ */
+
+/*
+ * End "k5-config.h"
+ */
+
+/*
+ * After loading the configuration definitions, load the Kerberos definitions.
+ */
+#include "krb5.h"
+
+#ifdef NEED_SOCKETS
+#include "port-sockets.h"
+#endif
+
+/* krb5/krb5.h includes many other .h files in the krb5 subdirectory.
+   The ones that it doesn't include, we include below.  */
+
+/*
+ * Begin "k5-errors.h"
+ */
+#ifndef KRB5_ERRORS__
+#define KRB5_ERRORS__
+
+
+/* Error codes used in KRB_ERROR protocol messages.
+   Return values of library routines are based on a different error table
+   (which allows non-ambiguous error codes between subsystems) */
+
+/* KDC errors */
+#define	KDC_ERR_NONE			0 /* No error */
+#define	KDC_ERR_NAME_EXP		1 /* Client's entry in DB expired */
+#define	KDC_ERR_SERVICE_EXP		2 /* Server's entry in DB expired */
+#define	KDC_ERR_BAD_PVNO		3 /* Requested pvno not supported */
+#define	KDC_ERR_C_OLD_MAST_KVNO		4 /* C's key encrypted in old master */
+#define	KDC_ERR_S_OLD_MAST_KVNO		5 /* S's key encrypted in old master */
+#define	KDC_ERR_C_PRINCIPAL_UNKNOWN	6 /* Client not found in Kerberos DB */
+#define	KDC_ERR_S_PRINCIPAL_UNKNOWN	7 /* Server not found in Kerberos DB */
+#define	KDC_ERR_PRINCIPAL_NOT_UNIQUE	8 /* Multiple entries in Kerberos DB */
+#define	KDC_ERR_NULL_KEY		9 /* The C or S has a null key */
+#define	KDC_ERR_CANNOT_POSTDATE		10 /* Tkt ineligible for postdating */
+#define	KDC_ERR_NEVER_VALID		11 /* Requested starttime > endtime */
+#define	KDC_ERR_POLICY			12 /* KDC policy rejects request */
+#define	KDC_ERR_BADOPTION		13 /* KDC can't do requested opt. */
+#define	KDC_ERR_ENCTYPE_NOSUPP		14 /* No support for encryption type */
+#define KDC_ERR_SUMTYPE_NOSUPP		15 /* No support for checksum type */
+#define KDC_ERR_PADATA_TYPE_NOSUPP	16 /* No support for padata type */
+#define KDC_ERR_TRTYPE_NOSUPP		17 /* No support for transited type */
+#define KDC_ERR_CLIENT_REVOKED		18 /* C's creds have been revoked */
+#define KDC_ERR_SERVICE_REVOKED		19 /* S's creds have been revoked */
+#define KDC_ERR_TGT_REVOKED		20 /* TGT has been revoked */
+#define KDC_ERR_CLIENT_NOTYET		21 /* C not yet valid */
+#define KDC_ERR_SERVICE_NOTYET		22 /* S not yet valid */
+#define KDC_ERR_KEY_EXP			23 /* Password has expired */
+#define KDC_ERR_PREAUTH_FAILED		24 /* Preauthentication failed */
+#define KDC_ERR_PREAUTH_REQUIRED	25 /* Additional preauthentication */
+					   /* required */
+#define KDC_ERR_SERVER_NOMATCH		26 /* Requested server and */
+					   /* ticket don't match*/
+/* Application errors */
+#define	KRB_AP_ERR_BAD_INTEGRITY 31	/* Decrypt integrity check failed */
+#define	KRB_AP_ERR_TKT_EXPIRED	32	/* Ticket expired */
+#define	KRB_AP_ERR_TKT_NYV	33	/* Ticket not yet valid */
+#define	KRB_AP_ERR_REPEAT	34	/* Request is a replay */
+#define	KRB_AP_ERR_NOT_US	35	/* The ticket isn't for us */
+#define	KRB_AP_ERR_BADMATCH	36	/* Ticket/authenticator don't match */
+#define	KRB_AP_ERR_SKEW		37	/* Clock skew too great */
+#define	KRB_AP_ERR_BADADDR	38	/* Incorrect net address */
+#define	KRB_AP_ERR_BADVERSION	39	/* Protocol version mismatch */
+#define	KRB_AP_ERR_MSG_TYPE	40	/* Invalid message type */
+#define	KRB_AP_ERR_MODIFIED	41	/* Message stream modified */
+#define	KRB_AP_ERR_BADORDER	42	/* Message out of order */
+#define	KRB_AP_ERR_BADKEYVER	44	/* Key version is not available */
+#define	KRB_AP_ERR_NOKEY	45	/* Service key not available */
+#define	KRB_AP_ERR_MUT_FAIL	46	/* Mutual authentication failed */
+#define KRB_AP_ERR_BADDIRECTION	47 	/* Incorrect message direction */
+#define KRB_AP_ERR_METHOD	48 	/* Alternative authentication */
+					/* method required */
+#define KRB_AP_ERR_BADSEQ	49 	/* Incorrect sequence numnber */
+					/* in message */
+#define KRB_AP_ERR_INAPP_CKSUM	50	/* Inappropriate type of */
+					/* checksum in message */
+
+/* other errors */
+#define KRB_ERR_GENERIC		60 	/* Generic error (description */
+					/* in e-text) */
+#define	KRB_ERR_FIELD_TOOLONG	61	/* Field is too long for impl. */
+
+#endif /* KRB5_ERRORS__ */
+/*
+ * End "k5-errors.h"
+ */
+
+/*
+ * This structure is returned in the e-data field of the KRB-ERROR
+ * message when the error calling for an alternative form of
+ * authentication is returned, KRB_AP_METHOD.
+ */
+typedef struct _krb5_alt_method {
+	krb5_magic	magic;
+	krb5_int32	method;
+	int		length;
+	krb5_octet	*data;
+} krb5_alt_method;
+
+/*
+ * A null-terminated array of this structure is returned by the KDC as
+ * the data part of the ETYPE_INFO preauth type.  It informs the
+ * client which encryption types are supported.
+ */
+typedef struct _krb5_etype_info_entry {
+	krb5_magic	magic;
+	krb5_enctype	etype;
+	int		length;
+	krb5_octet	*salt;
+} krb5_etype_info_entry;
+
+typedef krb5_etype_info_entry ** krb5_etype_info;
+
+/*
+ * a sam_challenge is returned for alternate preauth 
+ */
+/*
+          SAMFlags ::= BIT STRING {
+              use-sad-as-key[0],
+              send-encrypted-sad[1],
+              must-pk-encrypt-sad[2]
+          }
+ */
+/*
+          PA-SAM-CHALLENGE ::= SEQUENCE {
+              sam-type[0]                 INTEGER,
+              sam-flags[1]                SAMFlags,
+              sam-type-name[2]            GeneralString OPTIONAL,
+              sam-track-id[3]             GeneralString OPTIONAL,
+              sam-challenge-label[4]      GeneralString OPTIONAL,
+              sam-challenge[5]            GeneralString OPTIONAL,
+              sam-response-prompt[6]      GeneralString OPTIONAL,
+              sam-pk-for-sad[7]           EncryptionKey OPTIONAL,
+              sam-nonce[8]                INTEGER OPTIONAL,
+              sam-cksum[9]                Checksum OPTIONAL
+          }
+*/
+/* sam_type values -- informational only */
+#define PA_SAM_TYPE_ENIGMA     1   /*  Enigma Logic */
+#define PA_SAM_TYPE_DIGI_PATH  2   /*  Digital Pathways */
+#define PA_SAM_TYPE_SKEY_K0    3   /*  S/key where  KDC has key 0 */
+#define PA_SAM_TYPE_SKEY       4   /*  Traditional S/Key */
+#define PA_SAM_TYPE_SECURID    5   /*  Security Dynamics */
+#define PA_SAM_TYPE_GRAIL    128 /* experimental */
+
+typedef struct _krb5_predicted_sam_response {
+	krb5_magic	magic;
+	krb5_keyblock	sam_key;
+} krb5_predicted_sam_response;
+
+typedef struct _krb5_sam_challenge {
+	krb5_magic	magic;
+	krb5_int32	sam_type; /* information */
+	krb5_flags	sam_flags; /* KRB5_SAM_* values */
+	krb5_data	sam_type_name;
+	krb5_data	sam_track_id;
+	krb5_data	sam_challenge_label;
+	krb5_data	sam_challenge;
+	krb5_data	sam_response_prompt;
+	krb5_data	sam_pk_for_sad;
+	krb5_int32	sam_nonce;
+	krb5_checksum	sam_cksum;
+} krb5_sam_challenge;
+
+typedef struct _krb5_sam_key {	/* reserved for future use */
+	krb5_magic	magic;
+	krb5_keyblock	sam_key;
+} krb5_sam_key;
+
+typedef struct _krb5_enc_sam_response_enc {
+	krb5_magic	magic;
+	krb5_int32	sam_nonce;
+	krb5_timestamp	sam_timestamp;
+	krb5_int32	sam_usec;
+	krb5_data	sam_passcode;
+} krb5_enc_sam_response_enc;
+
+typedef struct _krb5_sam_response {
+	krb5_magic	magic;
+	krb5_int32	sam_type; /* informational */
+	krb5_flags	sam_flags; /* KRB5_SAM_* values */
+	krb5_data	sam_track_id; /* copied */
+	krb5_enc_data	sam_enc_key; /* krb5_sam_key - future use */
+	krb5_enc_data	sam_enc_nonce_or_ts; /* krb5_enc_sam_response_enc */
+	krb5_int32	sam_nonce;
+	krb5_timestamp	sam_patimestamp;
+} krb5_sam_response;
+
+
+/*
+ * Begin "dbm.h"
+ */
+#if !defined(_MACINTOSH) && !defined(_MSDOS) && !defined(_WIN32)
+
+/*
+ * Since we are always using db, use the db-ndbm include header file.
+ */	
+
+#include "db-ndbm.h"
+	
+#endif /* !MSDOS && !MACINTOSH */
+/*
+ * End "dbm.h"
+ */
+
+/*
+ * Begin "ext-proto.h"
+ */
+#ifndef KRB5_EXT_PROTO__
+#define KRB5_EXT_PROTO__
+
+#ifdef HAS_STDLIB_H
+#include <stdlib.h>
+#else
+#if defined(__STDC__) || defined(_MSDOS)
+#ifdef NO_STDLIB_H
+#include <fake-stdlib.h>
+#else
+#include <stdlib.h>
+#endif /* NO_STDLIB_H */
+#else
+extern char *malloc(), *realloc(), *calloc();
+extern char *getenv();
+#endif /* ! __STDC__ */
+#endif /* HAS_STDLIB_H */
+
+#ifdef USE_STRING_H
+#include <string.h>
+#else
+#include <strings.h>
+#endif
+
+#ifndef HAS_STRDUP
+extern char *strdup KRB5_PROTOTYPE((const char *));
+#endif
+
+#ifdef HAS_UNISTD_H
+#include <unistd.h>
+#endif
+
+#endif /* KRB5_EXT_PROTO__ */
+/*
+ * End "ext-proto.h"
+ */
+
+/*
+ * Begin "sysincl.h"
+ */
+#ifndef KRB5_SYSINCL__
+#define KRB5_SYSINCL__
+
+#ifndef KRB5_SYSTYPES__
+#define KRB5_SYSTYPES__
+/* needed for much of the rest -- but already handled in krb5.h? */
+/* #include <sys/types.h> */
+#endif /* KRB5_SYSTYPES__ */
+
+#ifdef HAVE_SYS_TIME_H
+#include <sys/time.h>
+#ifdef TIME_WITH_SYS_TIME
+#include <time.h>
+#endif
+#else
+#include <time.h>
+#endif
+
+#ifdef HAVE_SYS_STAT_H
+#include <sys/stat.h>			/* struct stat, stat() */
+#endif
+
+#ifdef HAVE_SYS_PARAM_H
+#include <sys/param.h>			/* MAXPATHLEN */
+#endif
+
+#ifdef HAVE_SYS_FILE_H
+#include <sys/file.h>			/* prototypes for file-related
+					   syscalls; flags for open &
+					   friends */
+#endif
+
+#include <fcntl.h>
+
+#endif /* KRB5_SYSINCL__ */
+/*
+ * End "sysincl.h"
+ */
+
+/*
+ * Begin "los-proto.h"
+ */
+#ifndef KRB5_LIBOS_PROTO__
+#define KRB5_LIBOS_PROTO__
+
+#include <stdio.h>
+
+/* libos.spec */
+krb5_error_code krb5_lock_file
+	KRB5_PROTOTYPE((krb5_context,
+		        int,
+		        int));
+krb5_error_code krb5_unlock_file
+	KRB5_PROTOTYPE((krb5_context,
+			int));
+int krb5_net_read
+	KRB5_PROTOTYPE((krb5_context,
+		   int ,
+		   char *,
+		   int  ));
+int krb5_net_write
+	KRB5_PROTOTYPE((krb5_context,
+		   int ,
+		   const char *,
+		   int  ));
+krb5_error_code krb5_sendto_kdc
+	KRB5_PROTOTYPE((krb5_context,
+		   const krb5_data *,
+		   const krb5_data *,
+		   krb5_data * ));
+krb5_error_code krb5_get_krbhst
+	KRB5_PROTOTYPE((krb5_context,
+		   const krb5_data *,
+		   char *** ));
+krb5_error_code krb5_free_krbhst
+	KRB5_PROTOTYPE((krb5_context,
+		   char * const * ));
+krb5_error_code krb5_random_confounder
+	KRB5_PROTOTYPE((int,
+		   krb5_pointer ));
+krb5_error_code krb5_gen_replay_name
+    KRB5_PROTOTYPE((krb5_context,
+		   const krb5_address *,
+	       const char *,
+	       char **));
+krb5_error_code krb5_create_secure_file
+	KRB5_PROTOTYPE((krb5_context,
+		   const char * pathname));
+krb5_error_code krb5_sync_disk_file
+	KRB5_PROTOTYPE((krb5_context,
+		   FILE *fp));
+
+
+krb5_error_code krb5_read_message 
+	KRB5_PROTOTYPE((krb5_context,
+		   krb5_pointer, 
+		   krb5_data *));
+krb5_error_code krb5_write_message 
+	KRB5_PROTOTYPE((krb5_context,
+		   krb5_pointer, 
+		   krb5_data *));
+
+krb5_error_code krb5_os_init_context
+        KRB5_PROTOTYPE((krb5_context));
+
+void krb5_os_free_context
+        KRB5_PROTOTYPE((krb5_context));
+
+krb5_error_code krb5_find_config_files
+        KRB5_PROTOTYPE(());
+
+
+/* in here to deal with stuff from lib/crypto/os */
+
+krb5_error_code krb5_crypto_os_localaddr
+    KRB5_PROTOTYPE((krb5_address ***));
+
+krb5_error_code krb5_crypto_us_timeofday
+    KRB5_PROTOTYPE((krb5_int32 *,
+		    krb5_int32 *));
+
+time_t gmt_mktime KRB5_PROTOTYPE((struct tm *));
+
+#endif /* KRB5_LIBOS_PROTO__ */
+/*
+ * End "los-proto.h"
+ */
+
+/*
+ * Include the KDB definitions.
+ */
+#include "kdb.h"
+#include "kdb_dbm.h"
+
+/*
+ * Begin "libos.h"
+ */
+#ifndef KRB5_LIBOS__
+#define KRB5_LIBOS__
+
+typedef struct _krb5_os_context {
+	krb5_magic	magic;
+	krb5_int32	time_offset;
+	krb5_int32	usec_offset;
+	krb5_int32	os_flags;
+} *krb5_os_context;
+
+/*
+ * Flags for the os_flags field
+ *
+ * KRB5_OS_TOFFSET_VALID means that the time offset fields are valid.
+ * The intention is that this facility to correct the system clocks so
+ * that they reflect the "real" time, for systems where for some
+ * reason we can't set the system clock.  Instead we calculate the
+ * offset between the system time and real time, and store the offset
+ * in the os context so that we can correct the system clock as necessary.
+ *
+ * KRB5_OS_TOFFSET_TIME means that the time offset fields should be
+ * returned as the time by the krb5 time routines.  This should only
+ * be used for testing purposes (obviously!)
+ */
+#define KRB5_OS_TOFFSET_VALID	1
+#define KRB5_OS_TOFFSET_TIME	2
+
+/* lock mode flags */
+#define	KRB5_LOCKMODE_SHARED	0x0001
+#define	KRB5_LOCKMODE_EXCLUSIVE	0x0002
+#define	KRB5_LOCKMODE_DONTBLOCK	0x0004
+#define	KRB5_LOCKMODE_UNLOCK	0x0008
+
+#endif /* KRB5_LIBOS__ */
+/*
+ * End "libos.h"
+ */
+
+/*
+ * Define our view of the size of a DES key.
+ */
+#define	KRB5_MIT_DES_KEYSIZE		8
+/*
+ * Check if des_int.h has been included before us.  If so, then check to see
+ * that our view of the DES key size is the same as des_int.h's.
+ */
+#ifdef	MIT_DES_KEYSIZE
+#if	MIT_DES_KEYSIZE != KRB5_MIT_DES_KEYSIZE
+error(MIT_DES_KEYSIZE does not equal KRB5_MIT_DES_KEYSIZE)
+#endif	/* MIT_DES_KEYSIZE != KRB5_MIT_DES_KEYSIZE */
+#endif	/* MIT_DES_KEYSIZE */
+
+/*
+ * Begin "preauth.h"
+ *
+ * (Originally written by Glen Machin at Sandia Labs.)
+ */
+/*
+ * Sandia National Laboratories also makes no representations about the 
+ * suitability of the modifications, or additions to this software for 
+ * any purpose.  It is provided "as is" without express or implied warranty.
+ * 
+ */
+#ifndef KRB5_PREAUTH__
+#define KRB5_PREAUTH__
+
+typedef struct _krb5_pa_enc_ts {
+    krb5_timestamp	patimestamp;
+    krb5_int32		pausec;
+} krb5_pa_enc_ts;
+
+typedef krb5_error_code (*krb5_preauth_obtain_proc)
+    KRB5_NPROTOTYPE((krb5_context,
+		    krb5_pa_data *,
+		    krb5_etype_info,
+		    krb5_keyblock *, 
+		    krb5_error_code ( * )(krb5_context,
+					  krb5_const krb5_enctype,
+					  krb5_data *,
+					  krb5_const_pointer,
+					  krb5_keyblock **),
+		    krb5_const_pointer,
+		    krb5_creds *,
+		    krb5_kdc_req *,
+		    krb5_pa_data **));
+
+typedef krb5_error_code (*krb5_preauth_process_proc)
+    KRB5_NPROTOTYPE((krb5_context,
+		    krb5_pa_data *,
+		    krb5_kdc_req *,
+		    krb5_kdc_rep *,
+		    krb5_error_code ( * )(krb5_context,
+					  krb5_const krb5_enctype,
+					  krb5_data *,
+					  krb5_const_pointer,
+					  krb5_keyblock **),
+		    krb5_const_pointer,
+		    krb5_error_code ( * )(krb5_context,
+					  krb5_const krb5_keyblock *,
+					  krb5_const_pointer,
+					  krb5_kdc_rep * ),
+		    krb5_keyblock **,
+		    krb5_creds *, 
+		    krb5_int32 *,
+		    krb5_int32 *));
+
+typedef struct _krb5_preauth_ops {
+    krb5_magic magic;
+    int     type;
+    int	flags;
+    krb5_preauth_obtain_proc	obtain;
+    krb5_preauth_process_proc	process;
+} krb5_preauth_ops;
+
+krb5_error_code krb5_obtain_padata
+    	KRB5_PROTOTYPE((krb5_context,
+		krb5_pa_data **,
+		krb5_error_code ( * )KRB5_NPROTOTYPE((krb5_context,
+						      krb5_const krb5_enctype,
+						      krb5_data *,
+						      krb5_const_pointer,
+						      krb5_keyblock **)),
+		krb5_const_pointer, 
+		krb5_creds *,
+		krb5_kdc_req *));
+
+krb5_error_code krb5_process_padata
+	KRB5_PROTOTYPE((krb5_context,
+		krb5_kdc_req *,
+		krb5_kdc_rep *,
+		krb5_error_code ( * )KRB5_NPROTOTYPE((krb5_context,
+						      krb5_const krb5_enctype,
+						      krb5_data *,
+						      krb5_const_pointer,
+						      krb5_keyblock **)),
+		krb5_const_pointer,
+		krb5_error_code ( * )KRB5_NPROTOTYPE((krb5_context,
+						      krb5_const krb5_keyblock *,
+						      krb5_const_pointer,
+						      krb5_kdc_rep * )),
+		krb5_keyblock **, 	
+		krb5_creds *, 
+		krb5_int32 *));		
+
+void krb5_free_etype_info
+    KRB5_PROTOTYPE((krb5_context, krb5_etype_info));
+
+/*
+ * Preauthentication property flags
+ */
+#define KRB5_PREAUTH_FLAGS_ENCRYPT	0x00000001
+#define KRB5_PREAUTH_FLAGS_HARDWARE	0x00000002
+
+#endif /* KRB5_PREAUTH__ */
+/*
+ * End "preauth.h"
+ */
+
+/* #include "krb5/wordsize.h" -- comes in through base-defs.h. */
+#include "profile.h"
+
+struct _krb5_context {
+	krb5_magic	magic;
+	krb5_enctype  FAR *in_tkt_ktypes;
+	int		in_tkt_ktype_count;
+	krb5_enctype  FAR *tgs_ktypes;
+	int		tgs_ktype_count;
+	void	      FAR *os_context;
+	char	      FAR *default_realm;
+	profile_t     profile;
+	void	      FAR *db_context;
+	int		ser_ctx_count;
+	void	      	FAR *ser_ctx;
+	krb5_deltat 	clockskew; /* allowable clock skew */
+	krb5_cksumtype	kdc_req_sumtype;
+	krb5_cksumtype	default_ap_req_sumtype;
+	krb5_cksumtype	default_safe_sumtype;
+	krb5_flags 	kdc_default_options;
+	krb5_flags	library_options;
+	krb5_boolean	profile_secure;
+	int		fcc_default_format;
+	int		scc_default_format;
+};
+
+#define KRB5_LIBOPT_SYNC_KDCTIME	0x0001
+
+/*
+ * Begin "asn1.h"
+ */
+#ifndef KRB5_ASN1__
+#define KRB5_ASN1__
+
+/* ASN.1 encoding knowledge; KEEP IN SYNC WITH ASN.1 defs! */
+/* here we use some knowledge of ASN.1 encodings */
+/* 
+  Ticket is APPLICATION 1.
+  Authenticator is APPLICATION 2.
+  AS_REQ is APPLICATION 10.
+  AS_REP is APPLICATION 11.
+  TGS_REQ is APPLICATION 12.
+  TGS_REP is APPLICATION 13.
+  AP_REQ is APPLICATION 14.
+  AP_REP is APPLICATION 15.
+  KRB_SAFE is APPLICATION 20.
+  KRB_PRIV is APPLICATION 21.
+  KRB_CRED is APPLICATION 22.
+  EncASRepPart is APPLICATION 25.
+  EncTGSRepPart is APPLICATION 26.
+  EncAPRepPart is APPLICATION 27.
+  EncKrbPrivPart is APPLICATION 28.
+  EncKrbCredPart is APPLICATION 29.
+  KRB_ERROR is APPLICATION 30.
+ */
+/* allow either constructed or primitive encoding, so check for bit 6
+   set or reset */
+#define krb5_is_krb_ticket(dat)\
+	((dat) && (dat)->length && ((dat)->data[0] == 0x61 ||\
+				    (dat)->data[0] == 0x41))
+#define krb5_is_krb_authenticator(dat)\
+	((dat) && (dat)->length && ((dat)->data[0] == 0x62 ||\
+				    (dat)->data[0] == 0x42))
+#define krb5_is_as_req(dat)\
+	((dat) && (dat)->length && ((dat)->data[0] == 0x6a ||\
+				    (dat)->data[0] == 0x4a))
+#define krb5_is_as_rep(dat)\
+	((dat) && (dat)->length && ((dat)->data[0] == 0x6b ||\
+				    (dat)->data[0] == 0x4b))
+#define krb5_is_tgs_req(dat)\
+	((dat) && (dat)->length && ((dat)->data[0] == 0x6c ||\
+				    (dat)->data[0] == 0x4c))
+#define krb5_is_tgs_rep(dat)\
+	((dat) && (dat)->length && ((dat)->data[0] == 0x6d ||\
+				    (dat)->data[0] == 0x4d))
+#define krb5_is_ap_req(dat)\
+	((dat) && (dat)->length && ((dat)->data[0] == 0x6e ||\
+				    (dat)->data[0] == 0x4e))
+#define krb5_is_ap_rep(dat)\
+	((dat) && (dat)->length && ((dat)->data[0] == 0x6f ||\
+				    (dat)->data[0] == 0x4f))
+#define krb5_is_krb_safe(dat)\
+	((dat) && (dat)->length && ((dat)->data[0] == 0x74 ||\
+				    (dat)->data[0] == 0x54))
+#define krb5_is_krb_priv(dat)\
+	((dat) && (dat)->length && ((dat)->data[0] == 0x75 ||\
+				    (dat)->data[0] == 0x55))
+#define krb5_is_krb_cred(dat)\
+	((dat) && (dat)->length && ((dat)->data[0] == 0x76 ||\
+				    (dat)->data[0] == 0x56))
+#define krb5_is_krb_enc_as_rep_part(dat)\
+	((dat) && (dat)->length && ((dat)->data[0] == 0x79 ||\
+				    (dat)->data[0] == 0x59))
+#define krb5_is_krb_enc_tgs_rep_part(dat)\
+	((dat) && (dat)->length && ((dat)->data[0] == 0x7a ||\
+				    (dat)->data[0] == 0x5a))
+#define krb5_is_krb_enc_ap_rep_part(dat)\
+	((dat) && (dat)->length && ((dat)->data[0] == 0x7b ||\
+				    (dat)->data[0] == 0x5b))
+#define krb5_is_krb_enc_krb_priv_part(dat)\
+	((dat) && (dat)->length && ((dat)->data[0] == 0x7c ||\
+				    (dat)->data[0] == 0x5c))
+#define krb5_is_krb_enc_krb_cred_part(dat)\
+	((dat) && (dat)->length && ((dat)->data[0] == 0x7d ||\
+				    (dat)->data[0] == 0x5d))
+#define krb5_is_krb_error(dat)\
+	((dat) && (dat)->length && ((dat)->data[0] == 0x7e ||\
+				    (dat)->data[0] == 0x5e))
+
+/*************************************************************************
+ * Prototypes for krb5_encode.c
+ *************************************************************************/
+
+/*
+   krb5_error_code encode_krb5_structure(const krb5_structure *rep,
+					 krb5_data **code);
+   modifies  *code
+   effects   Returns the ASN.1 encoding of *rep in **code.
+             Returns ASN1_MISSING_FIELD if a required field is emtpy in *rep.
+             Returns ENOMEM if memory runs out.
+*/
+
+krb5_error_code encode_krb5_authenticator
+	KRB5_PROTOTYPE((const krb5_authenticator *rep, krb5_data **code));
+
+krb5_error_code encode_krb5_ticket
+	KRB5_PROTOTYPE((const krb5_ticket *rep, krb5_data **code));
+
+krb5_error_code encode_krb5_encryption_key
+	KRB5_PROTOTYPE((const krb5_keyblock *rep, krb5_data **code));
+
+krb5_error_code encode_krb5_enc_tkt_part
+	KRB5_PROTOTYPE((const krb5_enc_tkt_part *rep, krb5_data **code));
+
+krb5_error_code encode_krb5_enc_kdc_rep_part
+	KRB5_PROTOTYPE((const krb5_enc_kdc_rep_part *rep, krb5_data **code));
+
+/* yes, the translation is identical to that used for KDC__REP */ 
+krb5_error_code encode_krb5_as_rep
+	KRB5_PROTOTYPE((const krb5_kdc_rep *rep, krb5_data **code));
+
+/* yes, the translation is identical to that used for KDC__REP */ 
+krb5_error_code encode_krb5_tgs_rep
+	KRB5_PROTOTYPE((const krb5_kdc_rep *rep, krb5_data **code));
+
+krb5_error_code encode_krb5_ap_req
+	KRB5_PROTOTYPE((const krb5_ap_req *rep, krb5_data **code));
+
+krb5_error_code encode_krb5_ap_rep
+	KRB5_PROTOTYPE((const krb5_ap_rep *rep, krb5_data **code));
+
+krb5_error_code encode_krb5_ap_rep_enc_part
+	KRB5_PROTOTYPE((const krb5_ap_rep_enc_part *rep, krb5_data **code));
+
+krb5_error_code encode_krb5_as_req
+	KRB5_PROTOTYPE((const krb5_kdc_req *rep, krb5_data **code));
+
+krb5_error_code encode_krb5_tgs_req
+	KRB5_PROTOTYPE((const krb5_kdc_req *rep, krb5_data **code));
+
+krb5_error_code encode_krb5_kdc_req_body
+	KRB5_PROTOTYPE((const krb5_kdc_req *rep, krb5_data **code));
+
+krb5_error_code encode_krb5_safe
+	KRB5_PROTOTYPE((const krb5_safe *rep, krb5_data **code));
+
+krb5_error_code encode_krb5_priv
+	KRB5_PROTOTYPE((const krb5_priv *rep, krb5_data **code));
+
+krb5_error_code encode_krb5_enc_priv_part
+	KRB5_PROTOTYPE((const krb5_priv_enc_part *rep, krb5_data **code));
+
+krb5_error_code encode_krb5_cred
+	KRB5_PROTOTYPE((const krb5_cred *rep, krb5_data **code));
+
+krb5_error_code encode_krb5_enc_cred_part
+	KRB5_PROTOTYPE((const krb5_cred_enc_part *rep, krb5_data **code));
+
+krb5_error_code encode_krb5_error
+	KRB5_PROTOTYPE((const krb5_error *rep, krb5_data **code));
+
+krb5_error_code encode_krb5_authdata
+	KRB5_PROTOTYPE((const krb5_authdata **rep, krb5_data **code));
+
+krb5_error_code encode_krb5_pwd_sequence
+	KRB5_PROTOTYPE((const passwd_phrase_element *rep, krb5_data **code));
+
+krb5_error_code encode_krb5_pwd_data
+	KRB5_PROTOTYPE((const krb5_pwd_data *rep, krb5_data **code));
+
+krb5_error_code encode_krb5_padata_sequence
+	KRB5_PROTOTYPE((const krb5_pa_data ** rep, krb5_data **code));
+
+krb5_error_code encode_krb5_alt_method
+	KRB5_PROTOTYPE((const krb5_alt_method *, krb5_data **code));
+
+krb5_error_code encode_krb5_etype_info
+	KRB5_PROTOTYPE((const krb5_etype_info_entry **, krb5_data **code));
+
+krb5_error_code encode_krb5_enc_data
+    	KRB5_PROTOTYPE((const krb5_enc_data *, krb5_data **));
+
+krb5_error_code encode_krb5_pa_enc_ts
+    	KRB5_PROTOTYPE((const krb5_pa_enc_ts *, krb5_data **));
+
+krb5_error_code encode_krb5_sam_challenge
+	KRB5_PROTOTYPE((const krb5_sam_challenge * , krb5_data **));
+
+krb5_error_code encode_krb5_sam_key
+	KRB5_PROTOTYPE((const krb5_sam_key * , krb5_data **));
+
+krb5_error_code encode_krb5_enc_sam_response_enc
+	KRB5_PROTOTYPE((const krb5_enc_sam_response_enc * , krb5_data **));
+
+krb5_error_code encode_krb5_sam_response
+	KRB5_PROTOTYPE((const krb5_sam_response * , krb5_data **));
+
+krb5_error_code encode_krb5_predicted_sam_response
+	KRB5_PROTOTYPE((const krb5_predicted_sam_response * , krb5_data **));
+
+/*************************************************************************
+ * End of prototypes for krb5_encode.c
+ *************************************************************************/
+
+
+/*************************************************************************
+ * Prototypes for krb5_decode.c
+ *************************************************************************/
+
+/*
+   krb5_error_code decode_krb5_structure(const krb5_data *code,
+                                         krb5_structure **rep);
+                                         
+   requires  Expects **rep to not have been allocated;
+              a new *rep is allocated regardless of the old value.
+   effects   Decodes *code into **rep.
+	     Returns ENOMEM if memory is exhausted.
+             Returns asn1 and krb5 errors.
+*/
+
+krb5_error_code decode_krb5_authenticator
+	KRB5_PROTOTYPE((const krb5_data *code, krb5_authenticator **rep));
+
+krb5_error_code decode_krb5_ticket
+	KRB5_PROTOTYPE((const krb5_data *code, krb5_ticket **rep));
+
+krb5_error_code decode_krb5_encryption_key
+	KRB5_PROTOTYPE((const krb5_data *output, krb5_keyblock **rep));
+
+krb5_error_code decode_krb5_enc_tkt_part
+	KRB5_PROTOTYPE((const krb5_data *output, krb5_enc_tkt_part **rep));
+
+krb5_error_code decode_krb5_enc_kdc_rep_part
+	KRB5_PROTOTYPE((const krb5_data *output, krb5_enc_kdc_rep_part **rep));
+
+krb5_error_code decode_krb5_as_rep
+	KRB5_PROTOTYPE((const krb5_data *output, krb5_kdc_rep **rep));
+
+krb5_error_code decode_krb5_tgs_rep
+	KRB5_PROTOTYPE((const krb5_data *output, krb5_kdc_rep **rep));
+
+krb5_error_code decode_krb5_ap_req
+	KRB5_PROTOTYPE((const krb5_data *output, krb5_ap_req **rep));
+
+krb5_error_code decode_krb5_ap_rep
+	KRB5_PROTOTYPE((const krb5_data *output, krb5_ap_rep **rep));
+
+krb5_error_code decode_krb5_ap_rep_enc_part
+	KRB5_PROTOTYPE((const krb5_data *output, krb5_ap_rep_enc_part **rep));
+
+krb5_error_code decode_krb5_as_req
+	KRB5_PROTOTYPE((const krb5_data *output, krb5_kdc_req **rep));
+
+krb5_error_code decode_krb5_tgs_req
+	KRB5_PROTOTYPE((const krb5_data *output, krb5_kdc_req **rep));
+
+krb5_error_code decode_krb5_kdc_req_body
+	KRB5_PROTOTYPE((const krb5_data *output, krb5_kdc_req **rep));
+
+krb5_error_code decode_krb5_safe
+	KRB5_PROTOTYPE((const krb5_data *output, krb5_safe **rep));
+
+krb5_error_code decode_krb5_priv
+	KRB5_PROTOTYPE((const krb5_data *output, krb5_priv **rep));
+
+krb5_error_code decode_krb5_enc_priv_part
+	KRB5_PROTOTYPE((const krb5_data *output, krb5_priv_enc_part **rep));
+
+krb5_error_code decode_krb5_cred
+	KRB5_PROTOTYPE((const krb5_data *output, krb5_cred **rep));
+
+krb5_error_code decode_krb5_enc_cred_part
+	KRB5_PROTOTYPE((const krb5_data *output, krb5_cred_enc_part **rep));
+
+krb5_error_code decode_krb5_error
+	KRB5_PROTOTYPE((const krb5_data *output, krb5_error **rep));
+
+krb5_error_code decode_krb5_authdata
+	KRB5_PROTOTYPE((const krb5_data *output, krb5_authdata ***rep));
+
+krb5_error_code decode_krb5_pwd_sequence
+	KRB5_PROTOTYPE((const krb5_data *output, passwd_phrase_element **rep));
+
+krb5_error_code decode_krb5_pwd_data
+	KRB5_PROTOTYPE((const krb5_data *output, krb5_pwd_data **rep));
+
+krb5_error_code decode_krb5_padata_sequence
+	KRB5_PROTOTYPE((const krb5_data *output, krb5_pa_data ***rep));
+
+krb5_error_code decode_krb5_alt_method
+	KRB5_PROTOTYPE((const krb5_data *output, krb5_alt_method **rep));
+
+krb5_error_code decode_krb5_etype_info
+	KRB5_PROTOTYPE((const krb5_data *output, krb5_etype_info_entry ***rep));
+
+krb5_error_code decode_krb5_enc_data
+	KRB5_PROTOTYPE((const krb5_data *output, krb5_enc_data **rep));
+
+krb5_error_code decode_krb5_pa_enc_ts
+	KRB5_PROTOTYPE((const krb5_data *output, krb5_pa_enc_ts **rep));
+
+krb5_error_code decode_krb5_sam_challenge
+	KRB5_PROTOTYPE((const krb5_data *, krb5_sam_challenge **));
+
+krb5_error_code decode_krb5_sam_key
+	KRB5_PROTOTYPE((const krb5_data *, krb5_sam_key **));
+
+krb5_error_code decode_krb5_enc_sam_response_enc
+	KRB5_PROTOTYPE((const krb5_data *, krb5_enc_sam_response_enc **));
+
+krb5_error_code decode_krb5_sam_response
+	KRB5_PROTOTYPE((const krb5_data *, krb5_sam_response **));
+
+krb5_error_code decode_krb5_predicted_sam_response
+	KRB5_PROTOTYPE((const krb5_data *, krb5_predicted_sam_response **));
+
+/*************************************************************************
+ * End of prototypes for krb5_decode.c
+ *************************************************************************/
+
+#endif /* KRB5_ASN1__ */
+/*
+ * End "asn1.h"
+ */
+
+
+/*
+ * Internal krb5 library routines
+ */
+krb5_error_code krb5_encrypt_tkt_part
+	KRB5_PROTOTYPE((krb5_context,
+		   krb5_const krb5_keyblock *,
+		   krb5_ticket * ));
+
+
+krb5_error_code krb5_encode_kdc_rep
+	KRB5_PROTOTYPE((krb5_context,
+		   krb5_const krb5_msgtype,
+		   krb5_const krb5_enc_kdc_rep_part *,
+		   krb5_const krb5_keyblock *,
+		   krb5_kdc_rep *,
+		   krb5_data ** ));
+
+krb5_error_code krb5_validate_times
+	KRB5_PROTOTYPE((krb5_context, 
+			krb5_ticket_times *));
+/*
+ * [De]Serialization Handle and operations.
+ */
+struct __krb5_serializer {
+    krb5_magic		odtype;
+    krb5_error_code	(*sizer) KRB5_NPROTOTYPE((krb5_context,
+						  krb5_pointer,
+						  size_t *));
+    krb5_error_code	(*externalizer) KRB5_NPROTOTYPE((krb5_context,
+							 krb5_pointer,
+							 krb5_octet **,
+							 size_t *));
+    krb5_error_code	(*internalizer) KRB5_NPROTOTYPE((krb5_context,
+							 krb5_pointer *,
+							 krb5_octet **,
+							 size_t *));
+};
+typedef struct __krb5_serializer * krb5_ser_handle;
+typedef struct __krb5_serializer krb5_ser_entry;
+
+krb5_ser_handle krb5_find_serializer KRB5_PROTOTYPE((krb5_context,
+						     krb5_magic));
+krb5_error_code krb5_register_serializer
+	KRB5_PROTOTYPE((krb5_context,
+			const krb5_ser_entry *));
+
+/* Determine the external size of a particular opaque structure */
+krb5_error_code krb5_size_opaque KRB5_PROTOTYPE((krb5_context,
+						 krb5_magic,
+						 krb5_pointer,
+						 size_t *));
+/* Serialize the structure into a buffer */
+krb5_error_code krb5_externalize_opaque KRB5_PROTOTYPE((krb5_context,
+							krb5_magic,
+							krb5_pointer,
+							krb5_octet **,
+							size_t *));
+/* Deserialize the structure from a buffer */
+krb5_error_code krb5_internalize_opaque KRB5_PROTOTYPE((krb5_context,
+							krb5_magic,
+							krb5_pointer *,
+							krb5_octet **,
+							size_t *));
+
+/* Serialize data into a buffer */
+krb5_error_code krb5_externalize_data KRB5_PROTOTYPE((krb5_context,
+						      krb5_pointer,
+						      krb5_octet **,
+						      size_t *));
+/*
+ * Initialization routines.
+ */
+
+/* Initialize serialization for krb5_[os_]context */
+krb5_error_code krb5_ser_context_init KRB5_PROTOTYPE((krb5_context));
+
+/* Initialize serialization for krb5_auth_context */
+krb5_error_code krb5_ser_auth_context_init KRB5_PROTOTYPE((krb5_context));
+
+/* Initialize serialization for krb5_keytab */
+krb5_error_code krb5_ser_keytab_init KRB5_PROTOTYPE((krb5_context));
+
+/* Initialize serialization for krb5_ccache */
+krb5_error_code krb5_ser_ccache_init KRB5_PROTOTYPE((krb5_context));
+
+/* Initialize serialization for krb5_rcache */
+krb5_error_code krb5_ser_rcache_init KRB5_PROTOTYPE((krb5_context));
+
+/* [De]serialize 4-byte integer */
+krb5_error_code krb5_ser_pack_int32 KRB5_PROTOTYPE((krb5_int32,
+						    krb5_octet **,
+						    size_t *));
+krb5_error_code krb5_ser_unpack_int32 KRB5_PROTOTYPE((krb5_int32 *,
+						      krb5_octet **,
+						      size_t *));
+/* [De]serialize byte string */
+krb5_error_code krb5_ser_pack_bytes KRB5_PROTOTYPE((krb5_octet *,
+						    size_t,
+						    krb5_octet **,
+						    size_t *));
+krb5_error_code krb5_ser_unpack_bytes KRB5_PROTOTYPE((krb5_octet *,
+						      size_t,
+						      krb5_octet **,
+						      size_t *));
+/*
+ * Convenience function for structure magic number
+ */
+#define KRB5_VERIFY_MAGIC(structure,magic_number) \
+    if ((structure)->magic != (magic_number)) return (magic_number);
+
+int krb5_seteuid  KRB5_PROTOTYPE((int));
+
+int krb5_setenv  KRB5_PROTOTYPE((const char *, const char *, int));
+
+void krb5_unsetenv  KRB5_PROTOTYPE((const char *));
+#endif /* _KRB5_INT_H */
diff -Nur pam_krb5-1.0-1/pam_krb5.c pam_krb5-1.0-1.orig/pam_krb5.c
--- pam_krb5-1.0-1/pam_krb5.c	Wed Dec 24 00:54:07 1997
+++ pam_krb5-1.0-1.orig/pam_krb5.c	Mon Dec 14 15:40:56 1998
@@ -43,7 +43,7 @@
 #include <netinet/in.h>
 
 /* NI, for kerberos 5 */
-#include <kadm5/admin.h>
+#include "admin.h"
 #include <krb5.h>
 #include <kpasswd_strings.h>
 #define string_text error_message
diff -Nur pam_krb5-1.0-1/support.-c pam_krb5-1.0-1.orig/support.-c
--- pam_krb5-1.0-1/support.-c	Wed Dec 24 01:22:02 1997
+++ pam_krb5-1.0-1.orig/support.-c	Mon Dec 14 15:40:56 1998
@@ -107,7 +107,7 @@
 }
 
 /* NI, definitions, from here */
-#define KRB5_DEFAULT_LIFE 60*60*10 /* 10 hours */
+#define KRB5_DEFAULT_LIFE 60*10 /* 10 minuts */
 krb5_data tgtname = {
     0,
     KRB5_TGS_NAME_SIZE,
@@ -133,12 +133,12 @@
 
 	  if (retval != PAM_SUCCESS && on(KRB5_DEBUG,ctrl) ) {
 	       _log_err(LOG_DEBUG, "conversation failure [%s]"
-			, pam_strerror(retval));
+			, pam_strerror(pamh, retval));
 	  }
 
      } else {
 	  _log_err(LOG_ERR, "couldn't obtain coversation function [%s]"
-	       , pam_strerror(retval));
+	       , pam_strerror(pamh, retval));
      }
 
      return retval;                  /* propagate error status */
@@ -269,17 +269,17 @@
      /* We need to deal with: 
       * PAM_CRED_ESTABLISH (get new cred)
       * PAM_CRED_DELETE (nuke creds)
-      * PAM_CRED_REINITIALIZE (not sure that we need to deal with this)
+      * PAM_REINITIALIZE_CRED (not sure that we need to deal with this)
       * PAM_CRED_REFRESH (ha ha)
       */
      
      switch (ctrl) {
-     case PAM_CRED_REINITIALIZE:
-     case PAM_CRED_REFRESH:
+     case PAM_REINITIALIZE_CRED:
+     case PAM_REFRESH_CRED:
        retval = PAM_CRED_UNAVAIL;
        break;
        
-     case PAM_CRED_DELETE:
+     case PAM_DELETE_CRED:
        {
 	 krb5_context context;
 	 krb5_ccache ccache = NULL;
@@ -301,7 +301,7 @@
 	 return PAM_SUCCESS;
 	 break;
        }
-     case PAM_CRED_ESTABLISH:
+     case PAM_ESTABLISH_CRED:
      default:
        {
 	 krb5_creds tgtcred;
@@ -594,7 +594,7 @@
 
      if (retval != PAM_SUCCESS) {
 	  _log_err(LOG_ERR, "unable to set username [%s]"
-		   , pam_strerror(retval));
+		   , pam_strerror(pamh, retval));
      }
      return retval;
 }
@@ -768,7 +768,7 @@
 	  retval = pam_set_data(pamh, data_name, (void *) token, _cleanup);
 	  if (retval != PAM_SUCCESS) {
 	       _log_err(LOG_CRIT, "error manipulating password data [%s]"
-		    , pam_strerror(retval) );
+		    , pam_strerror(pamh, retval) );
 	       token = _pam_delete(token);
 	       return retval;
 	  }
