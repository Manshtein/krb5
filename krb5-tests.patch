--- krb5-1.6/src/tests/resolve/Makefile.in~	2006-10-14 01:54:24.000000000 +0200
+++ krb5-1.6/src/tests/resolve/Makefile.in	2007-03-31 13:19:53.138858011 +0200
@@ -22,7 +22,7 @@
 	$(CC_LINK) -o $@ fake-addrinfo-test.o $(SUPPORT_LIB) $(LIBS)
 
 check:: resolve addrinfo-test
-	$(RUN_SETUP) $(VALGRIND) ./resolve
+	$(RUN_SETUP) $(VALGRIND) ./resolve www.pld-linux.org
 	$(RUN_SETUP) $(VALGRIND) ./addrinfo-test -p telnet
 	$(RUN_SETUP) $(VALGRIND) ./fake-addrinfo-test -p telnet
 
--- krb5-1.6/src/plugins/kdb/db2/libdb2/test/run.test~	2007-03-31 01:06:26.378820494 +0200
+++ krb5-1.6/src/plugins/kdb/db2/libdb2/test/run.test	2007-03-31 13:49:57.365675038 +0200
@@ -6,7 +6,7 @@
 # db regression tests
 main()
 {
-
+set -x
 	PROG=./dbtest
 	TMP1=${TMPDIR-.}/t1
 	TMP2=${TMPDIR-.}/t2
@@ -69,6 +69,7 @@
 }
 
 getnwords() {
+set -x
 	# Delete blank lines because the db code appears not to
 	# like empty keys.  On Debian Linux, $DICT appears to contain
 	# some non-ASCII characters, and "rev" chokes on them.
@@ -79,6 +80,7 @@
 # be key/data pairs.
 test1()
 {
+set -x
 	echo "Test 1: btree, hash: small key, small data pairs"
 	getnwords 200 > $TMP1
 	for type in btree hash; do
@@ -96,6 +96,10 @@
 		if (cmp -s $TMP1 $TMP3) ; then :
 		else
 			echo "test1: type $type: failed"
+			echo "$TMP1:"
+			cat $TMP1
+			echo "$TMP3:"
+			cat $TMP3
 			exit 1
 		fi
 	done
@@ -115,6 +117,7 @@
 # each a medium size data entry.
 test2()
 {
+set -x
 	echo "Test 2: btree, hash: small key, medium data pairs"
 	mdata=abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz
 	echo $mdata |
@@ -152,6 +155,7 @@
 # Insert the programs in $bindir with their paths as their keys.
 test3()
 {
+set -x
 	echo "Test 3: hash: small key, big data pairs"
 	rm -f $TMP1
 	(find $bindir -type f -exec test -r {} \; -print | xargs cat) > $TMP1
@@ -212,6 +216,7 @@
 # Do random recno entries.
 test4()
 {
+set -x
 	echo "Test 4: recno: random entries"
 	echo "abcdefg abcdefg abcdefg abcdefg abcdefg abcdefg abcdefg" |
 	awk '{
@@ -276,6 +281,7 @@
 # Do reverse order recno entries.
 test5()
 {
+set -x
 	echo "Test 5: recno: reverse order entries"
 	echo "abcdefg abcdefg abcdefg abcdefg abcdefg abcdefg abcdefg" |
 	awk ' {
@@ -312,6 +318,7 @@
 # Do alternating order recno entries.
 test6()
 {
+set -x
 	echo "Test 6: recno: alternating order entries"
 	echo "abcdefg abcdefg abcdefg abcdefg abcdefg abcdefg abcdefg" |
 	awk ' {
@@ -364,6 +371,7 @@
 # Delete cursor record
 test7()
 {
+set -x
 	echo "Test 7: btree, recno: delete cursor record"
 	echo "abcdefg abcdefg abcdefg abcdefg abcdefg abcdefg abcdefg" |
 	awk '{
@@ -407,6 +415,7 @@
 # Make sure that overflow pages are reused.
 test8()
 {
+set -x
 	echo "Test 8: btree: repeated small key, big data pairs"
 	rm -f $TMP1
 	echo "" | 
@@ -436,6 +445,7 @@
 # Test btree duplicate keys
 test9()
 {
+set -x
 	echo "Test 9: btree: duplicate keys"
 	echo "abcdefg abcdefg abcdefg abcdefg abcdefg abcdefg abcdefg" |
 	awk '{
@@ -469,6 +479,7 @@
 # Test use of cursor flags without initialization
 test10()
 {
+set -x
 	echo "Test 10: btree, recno: test cursor flag use"
 	echo "abcdefg abcdefg abcdefg abcdefg abcdefg abcdefg abcdefg" |
 	awk '{
@@ -518,6 +529,7 @@
 # Test insert in reverse order.
 test11()
 {
+set -x
 	echo "Test 11: recno: reverse order insert"
 	echo "abcdefg abcdefg abcdefg abcdefg abcdefg abcdefg abcdefg" |
 	awk '{
@@ -554,6 +566,7 @@
 # the btree split code gets hammered.
 test12()
 {
+set -x
 	echo "Test 12: skipped, rev not found"
 	return
 	if test $dictsize -lt 20001 ; then
@@ -587,6 +600,7 @@
 # Test different byte orders.
 test13()
 {
+set -x
 	echo "Test 13: btree, hash: differing byte orders"
 	getnwords 50 > $TMP1
 	for order in 1234 4321; do
@@ -624,6 +638,7 @@
 # Try a variety of bucketsizes and fill factors for hashing
 test20()
 {
+set -x
 	if test $dictsize -lt 10001 ; then
 		echo "Test 20: skipped, dictionary too small"
 		return
